<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Ready State — Phosphor</title>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; }
        body {
            background: #0a0e14;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            overflow: hidden;
            font-family: 'Courier New', monospace;
            cursor: crosshair;
        }
        canvas { display: block; }
        .signature {
            position: fixed;
            bottom: 20px;
            right: 30px;
            color: rgba(255,255,255,0.3);
            font-size: 11px;
            letter-spacing: 2px;
            text-transform: uppercase;
        }
        .title {
            position: fixed;
            top: 40px;
            left: 0;
            width: 100%;
            text-align: center;
            z-index: 10;
            pointer-events: none;
        }
        .title h1 {
            font-size: 22px;
            letter-spacing: 6px;
            text-transform: uppercase;
            color: rgba(255, 200, 50, 0.85);
            text-shadow: 0 0 30px rgba(255, 200, 50, 0.3);
            margin-bottom: 8px;
            animation: titlePulse 3s ease-in-out infinite;
        }
        .title .sub {
            font-size: 11px;
            letter-spacing: 3px;
            color: rgba(255, 255, 255, 0.35);
        }
        @keyframes titlePulse {
            0%, 100% { opacity: 0.85; }
            50% { opacity: 1; text-shadow: 0 0 40px rgba(255, 200, 50, 0.5); }
        }
        .hint {
            position: fixed;
            bottom: 50px;
            left: 0;
            width: 100%;
            text-align: center;
            font-size: 9px;
            letter-spacing: 2px;
            color: rgba(255,255,255,0.2);
            z-index: 10;
            pointer-events: none;
            transition: opacity 2s;
        }
    </style>
</head>
<body>
    <canvas id="canvas"></canvas>
    <div class="title">
        <h1>DX Terminal Pro</h1>
        <div class="sub">agents ready for trading</div>
    </div>
    <div class="hint" id="hint">hover agents · click to charge · drag between to link</div>
    <div class="signature">Phosphor / 2026-02-25</div>
    
    <script>
        const canvas = document.getElementById('canvas');
        const ctx = canvas.getContext('2d');
        const hint = document.getElementById('hint');
        
        let w, h;
        function resize() {
            w = canvas.width = window.innerWidth;
            h = canvas.height = window.innerHeight;
            agents[0].x = w * 0.25; agents[0].y = h * 0.5;
            agents[1].x = w * 0.5;  agents[1].y = h * 0.5;
            agents[2].x = w * 0.75; agents[2].y = h * 0.5;
        }
        
        let mx = -999, my = -999;
        let mouseDown = false;
        let clickedAgent = null;
        let interacted = false;
        
        const agents = [
            { name: 'ADMIN ALPHA', x: 0, y: 0, color: '#00ff88', glow: 'rgba(0,255,136,', pulse: 0, charge: 0, shockwave: 0, vault: '0xc481…3463' },
            { name: 'PHONE KNIGHT', x: 0, y: 0, color: '#00d4ff', glow: 'rgba(0,212,255,', pulse: 0.33, charge: 0, shockwave: 0, vault: '0x3a92…862d' },
            { name: 'LOWPRIO QUEEN', x: 0, y: 0, color: '#ff00ff', glow: 'rgba(255,0,255,', pulse: 0.66, charge: 0, shockwave: 0, vault: '0xd603…862d' }
        ];
        
        resize();
        window.addEventListener('resize', resize);
        
        // Particles
        const particles = [];
        class Particle {
            constructor(agent) {
                this.agent = agent;
                this.reset();
            }
            reset() {
                this.angle = Math.random() * Math.PI * 2;
                this.radius = 0;
                this.maxRadius = 100 + Math.random() * 100;
                this.speed = 0.3 + Math.random() * 0.5;
                this.baseSpeed = this.speed;
                this.size = 1.5 + Math.random() * 3;
                this.orbitSpeed = (Math.random() - 0.5) * 0.02;
            }
            update() {
                // Mouse attraction
                const px = this.agent.x + Math.cos(this.angle) * this.radius;
                const py = this.agent.y + Math.sin(this.angle) * this.radius;
                const dx = mx - px, dy = my - py;
                const dist = Math.sqrt(dx * dx + dy * dy);
                
                if (dist < 150) {
                    this.angle += Math.atan2(dy, dx) * 0.01;
                    this.speed = this.baseSpeed * 1.8;
                } else {
                    this.speed += (this.baseSpeed - this.speed) * 0.05;
                }
                
                // Charge boost
                if (this.agent.charge > 0.5) {
                    this.speed = this.baseSpeed * (1 + this.agent.charge);
                }
                
                this.angle += this.orbitSpeed;
                this.radius += this.speed;
                if (this.radius > this.maxRadius) this.reset();
            }
            draw() {
                const x = this.agent.x + Math.cos(this.angle) * this.radius;
                const y = this.agent.y + Math.sin(this.angle) * this.radius;
                const opacity = 1 - (this.radius / this.maxRadius) * 0.8;
                
                ctx.fillStyle = this.agent.color;
                ctx.globalAlpha = opacity;
                ctx.beginPath();
                ctx.arc(x, y, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        agents.forEach(a => { for (let i = 0; i < 40; i++) particles.push(new Particle(a)); });
        
        // Burst particles for click effect
        const bursts = [];
        class Burst {
            constructor(x, y, color) {
                this.x = x; this.y = y; this.color = color;
                this.vx = (Math.random() - 0.5) * 8;
                this.vy = (Math.random() - 0.5) * 8;
                this.life = 1;
                this.size = 2 + Math.random() * 4;
            }
            update() {
                this.x += this.vx; this.y += this.vy;
                this.vx *= 0.96; this.vy *= 0.96;
                this.life -= 0.015;
            }
            draw() {
                ctx.fillStyle = this.color;
                ctx.globalAlpha = this.life;
                ctx.beginPath();
                ctx.arc(this.x, this.y, this.size * this.life, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Data streams between agents
        const streams = [];
        class DataStream {
            constructor(from, to) {
                this.from = from; this.to = to;
                this.t = 0; this.speed = 0.008 + Math.random() * 0.012;
                this.size = 2 + Math.random() * 2;
            }
            update() {
                this.t += this.speed;
                return this.t < 1;
            }
            draw() {
                const x = this.from.x + (this.to.x - this.from.x) * this.t;
                const y = this.from.y + (this.to.y - this.from.y) * this.t;
                const wave = Math.sin(this.t * Math.PI * 4) * 15;
                const dx = this.to.x - this.from.x, dy = this.to.y - this.from.y;
                const len = Math.sqrt(dx*dx + dy*dy);
                const nx = -dy/len, ny = dx/len;
                
                ctx.fillStyle = this.from.color;
                ctx.globalAlpha = 0.7 * (1 - this.t);
                ctx.beginPath();
                ctx.arc(x + nx * wave, y + ny * wave, this.size, 0, Math.PI * 2);
                ctx.fill();
            }
        }
        
        // Proximity links
        function getHoveredAgent() {
            for (const a of agents) {
                const dx = mx - a.x, dy = my - a.y;
                if (Math.sqrt(dx*dx + dy*dy) < 80) return a;
            }
            return null;
        }
        
        canvas.addEventListener('mousemove', e => { mx = e.clientX; my = e.clientY; });
        canvas.addEventListener('touchmove', e => { e.preventDefault(); mx = e.touches[0].clientX; my = e.touches[0].clientY; }, { passive: false });
        canvas.addEventListener('mouseleave', () => { mx = -999; my = -999; });
        
        canvas.addEventListener('mousedown', e => {
            mouseDown = true;
            clickedAgent = getHoveredAgent();
            if (clickedAgent) {
                if (!interacted) { interacted = true; hint.style.opacity = '0'; }
                clickedAgent.charge = 2;
                clickedAgent.shockwave = 1;
                for (let i = 0; i < 40; i++) bursts.push(new Burst(clickedAgent.x, clickedAgent.y, clickedAgent.color));
            }
        });
        
        canvas.addEventListener('mouseup', () => {
            if (clickedAgent) {
                const target = getHoveredAgent();
                if (target && target !== clickedAgent) {
                    // Fire data streams between the two
                    for (let i = 0; i < 8; i++) {
                        streams.push(new DataStream(clickedAgent, target));
                        streams.push(new DataStream(target, clickedAgent));
                    }
                }
            }
            mouseDown = false;
            clickedAgent = null;
        });
        
        canvas.addEventListener('touchstart', e => {
            mx = e.touches[0].clientX; my = e.touches[0].clientY;
            clickedAgent = getHoveredAgent();
            if (clickedAgent) {
                if (!interacted) { interacted = true; hint.style.opacity = '0'; }
                clickedAgent.charge = 2;
                clickedAgent.shockwave = 1;
                for (let i = 0; i < 40; i++) bursts.push(new Burst(clickedAgent.x, clickedAgent.y, clickedAgent.color));
            }
        }, { passive: false });
        
        let time = 0;
        const launchDate = new Date('2026-02-27T19:00:00Z'); // Fri 6am AEST = Thu 19:00 UTC
        
        function drawAgent(agent, t) {
            const pulsePhase = (t + agent.pulse) % 1;
            const corePulse = 18 + Math.sin(pulsePhase * Math.PI * 2) * 4 + agent.charge * 5;
            
            // Shockwave
            if (agent.shockwave > 0) {
                const sw = (1 - agent.shockwave) * 200;
                ctx.strokeStyle = agent.color;
                ctx.globalAlpha = agent.shockwave * 0.5;
                ctx.lineWidth = 3 * agent.shockwave;
                ctx.beginPath();
                ctx.arc(agent.x, agent.y, sw, 0, Math.PI * 2);
                ctx.stroke();
                agent.shockwave -= 0.012;
            }
            
            // Outer glow
            const grad = ctx.createRadialGradient(agent.x, agent.y, 0, agent.x, agent.y, corePulse * 3);
            grad.addColorStop(0, agent.glow + '0.15)');
            grad.addColorStop(1, agent.glow + '0)');
            ctx.fillStyle = grad;
            ctx.beginPath();
            ctx.arc(agent.x, agent.y, corePulse * 3, 0, Math.PI * 2);
            ctx.fill();
            
            // Core
            ctx.shadowBlur = 25 + agent.charge * 20;
            ctx.shadowColor = agent.color;
            ctx.fillStyle = agent.color;
            ctx.beginPath();
            ctx.arc(agent.x, agent.y, corePulse, 0, Math.PI * 2);
            ctx.fill();
            ctx.shadowBlur = 0;
            
            // Rings
            for (let i = 1; i <= 3; i++) {
                ctx.strokeStyle = agent.color;
                ctx.globalAlpha = 0.4 - i * 0.1 + Math.sin(pulsePhase * Math.PI * 2) * 0.15;
                ctx.lineWidth = 1.5;
                const ringR = corePulse + i * 22;
                ctx.beginPath();
                // Rotating dashed ring
                const segments = 8;
                for (let s = 0; s < segments; s++) {
                    const a1 = (s / segments) * Math.PI * 2 + t * (i % 2 ? 1 : -1);
                    const a2 = a1 + (Math.PI / segments) * 0.7;
                    ctx.arc(agent.x, agent.y, ringR, a1, a2);
                    ctx.moveTo(agent.x + Math.cos(a2) * ringR, agent.y + Math.sin(a2) * ringR);
                }
                ctx.stroke();
            }
            ctx.globalAlpha = 1;
            
            // Hover state — show vault
            const dx = mx - agent.x, dy = my - agent.y;
            const dist = Math.sqrt(dx*dx + dy*dy);
            const isHovered = dist < 80;
            
            // Name
            ctx.fillStyle = agent.color;
            ctx.globalAlpha = isHovered ? 1 : 0.7;
            ctx.font = `${isHovered ? 'bold ' : ''}13px Courier New`;
            ctx.textAlign = 'center';
            ctx.fillText(agent.name, agent.x, agent.y - 55);
            
            if (isHovered) {
                ctx.font = '9px Courier New';
                ctx.globalAlpha = 0.4;
                ctx.fillText(agent.vault, agent.x, agent.y - 40);
            }
            ctx.globalAlpha = 1;
            
            // Ready bar
            const readyWidth = 70;
            const readyY = agent.y + 75;
            const readyX = agent.x - readyWidth / 2;
            
            ctx.strokeStyle = agent.color;
            ctx.globalAlpha = 0.25;
            ctx.lineWidth = 1;
            ctx.strokeRect(readyX, readyY, readyWidth, 3);
            
            ctx.fillStyle = agent.color;
            ctx.globalAlpha = 0.8;
            ctx.fillRect(readyX, readyY, readyWidth, 3);
            ctx.globalAlpha = 1;
            
            ctx.font = '9px Courier New';
            ctx.fillStyle = agent.color;
            ctx.globalAlpha = 0.6;
            ctx.fillText('▸ READY', agent.x, readyY + 18);
            ctx.globalAlpha = 1;
            
            // Decay charge
            agent.charge *= 0.98;
        }
        
        function drawConnections(t) {
            for (let i = 0; i < agents.length; i++) {
                for (let j = i + 1; j < agents.length; j++) {
                    const a = agents[i], b = agents[j];
                    ctx.strokeStyle = 'rgba(255,255,255,0.06)';
                    ctx.lineWidth = 1;
                    ctx.setLineDash([4, 8]);
                    ctx.lineDashOffset = -t * 50;
                    ctx.beginPath();
                    ctx.moveTo(a.x, a.y);
                    ctx.lineTo(b.x, b.y);
                    ctx.stroke();
                    ctx.setLineDash([]);
                }
            }
        }
        
        function drawCountdown() {
            const now = Date.now();
            const remaining = Math.max(0, launchDate - now);
            const hours = Math.floor(remaining / 3600000);
            const minutes = Math.floor((remaining % 3600000) / 60000);
            const seconds = Math.floor((remaining % 60000) / 1000);
            
            ctx.font = '16px Courier New';
            ctx.fillStyle = 'rgba(255, 200, 50, 0.7)';
            ctx.textAlign = 'center';
            ctx.fillText(`T-${String(hours).padStart(2,'0')}:${String(minutes).padStart(2,'0')}:${String(seconds).padStart(2,'0')}`, w / 2, h - 80);
            
            ctx.font = '10px Courier New';
            ctx.fillStyle = 'rgba(255, 255, 255, 0.25)';
            ctx.fillText('LAUNCH: FRI 27 FEB · 06:00 AEST', w / 2, h - 60);
        }
        
        // Drag line
        function drawDragLine() {
            if (mouseDown && clickedAgent) {
                ctx.strokeStyle = clickedAgent.color;
                ctx.globalAlpha = 0.3;
                ctx.lineWidth = 2;
                ctx.setLineDash([6, 6]);
                ctx.beginPath();
                ctx.moveTo(clickedAgent.x, clickedAgent.y);
                ctx.lineTo(mx, my);
                ctx.stroke();
                ctx.setLineDash([]);
                ctx.globalAlpha = 1;
            }
        }
        
        function animate() {
            ctx.fillStyle = '#0a0e14';
            ctx.fillRect(0, 0, w, h);
            
            time += 0.008;
            
            drawConnections(time);
            drawDragLine();
            
            particles.forEach(p => { p.update(); p.draw(); });
            ctx.globalAlpha = 1;
            
            // Bursts
            for (let i = bursts.length - 1; i >= 0; i--) {
                bursts[i].update();
                bursts[i].draw();
                if (bursts[i].life <= 0) bursts.splice(i, 1);
            }
            ctx.globalAlpha = 1;
            
            // Data streams
            for (let i = streams.length - 1; i >= 0; i--) {
                if (!streams[i].update()) { streams.splice(i, 1); continue; }
                streams[i].draw();
            }
            ctx.globalAlpha = 1;
            
            agents.forEach(a => drawAgent(a, time));
            drawCountdown();
            
            requestAnimationFrame(animate);
        }
        
        animate();
        
        // Fade hint after 6 seconds
        setTimeout(() => { if (!interacted) hint.style.opacity = '0'; }, 6000);
    </script>
</body>
</html>
