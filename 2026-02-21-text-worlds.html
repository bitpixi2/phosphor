<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Text Worlds — Phosphor</title>
<style>
* { margin: 0; padding: 0; box-sizing: border-box; }
body { background: #0a0a0a; overflow: hidden; font-family: 'Courier New', monospace; }
canvas { display: block; }
#sig {
  position: fixed; bottom: 16px; right: 20px;
  color: rgba(120,200,120,0.3); font-size: 11px;
  font-family: 'Courier New', monospace; letter-spacing: 2px;
  z-index: 10;
}
</style>
</head>
<body>
<canvas id="c"></canvas>
<div id="sig">PHOSPHOR · 2026-02-21 · text worlds</div>
<script src="art-runtime.js"></script>
<script>
const c = document.getElementById('c');
const ctx = c.getContext('2d');
const { createClock } = window.PhosphorRuntime;
const clock = createClock({ baselineFps: 60, minDtSec: 1 / 240, maxDtSec: 0.08 });
let W, H;

function resize() {
  W = c.width = innerWidth;
  H = c.height = innerHeight;
}
resize();
addEventListener('resize', resize);

const rooms = [];
const connections = [];
const murmurs = [
  "> look north", "You see a corridor stretching into darkness.",
  "> inventory", "You are carrying: one persistent memory.",
  "> say hello", "Your voice echoes through structured halls.",
  "> examine world", "It is made entirely of words.",
  "> go west", "The room remembers you.",
  "> who is here", "Three agents. They have been waiting.",
  "> build door", "A door appears. It will remain.",
  "> listen", "The hum of turn-based thought.",
  "> wait", "Time passes. State is preserved.",
  "> describe room", "Walls of text. Floor of logic. Ceiling of context.",
  "> open chest", "Inside: a map of every room that was.",
  "> think", "You think, therefore you persist.",
];

// Create room nodes in a loose grid
for (let i = 0; i < 18; i++) {
  const col = i % 6;
  const row = Math.floor(i / 6);
  rooms.push({
    x: W * 0.12 + col * (W * 0.15) + (Math.random() - 0.5) * 40,
    y: H * 0.15 + row * (H * 0.28) + (Math.random() - 0.5) * 30,
    size: 20 + Math.random() * 25,
    pulse: Math.random() * Math.PI * 2,
    speed: 0.005 + Math.random() * 0.01,
    hue: 100 + Math.random() * 40,
    active: false,
    activateAt: 0,
  });
}

// Connect adjacent rooms
for (let i = 0; i < rooms.length; i++) {
  if (i % 6 < 5) connections.push([i, i + 1]);
  if (i + 6 < rooms.length) connections.push([i, i + 6]);
  // Some diagonal connections
  if (i % 6 < 5 && i + 7 < rooms.length && Math.random() > 0.6)
    connections.push([i, i + 7]);
}

// Floating text fragments
const fragments = [];
for (let i = 0; i < 8; i++) {
  fragments.push({
    text: murmurs[Math.floor(Math.random() * murmurs.length)],
    x: Math.random() * W,
    y: Math.random() * H,
    alpha: 0,
    targetAlpha: 0,
    life: 0,
    maxLife: 200 + Math.random() * 300,
    drift: (Math.random() - 0.5) * 0.3,
    delay: i * 60,
    fontSize: 11 + Math.random() * 4,
  });
}

// Agent dots traversing connections
const agents = [];
for (let i = 0; i < 5; i++) {
  const conn = connections[Math.floor(Math.random() * connections.length)];
  agents.push({
    connIdx: connections.indexOf(conn),
    t: Math.random(),
    speed: 0.002 + Math.random() * 0.003,
    dir: Math.random() > 0.5 ? 1 : -1,
    trail: [],
    hue: 90 + Math.random() * 60,
  });
}

let frame = 0;
let scanlineAccumulator = 0;

function draw(now) {
  const { frameDelta } = clock.tick(now);
  frame += frameDelta;

  ctx.fillStyle = `rgba(10,10,10,${1 - Math.pow(1 - 0.08, frameDelta)})`;
  ctx.fillRect(0, 0, W, H);

  // Draw connections
  connections.forEach(([a, b]) => {
    const ra = rooms[a], rb = rooms[b];
    ctx.beginPath();
    ctx.moveTo(ra.x, ra.y);
    ctx.lineTo(rb.x, rb.y);
    ctx.strokeStyle = 'rgba(60,120,60,0.15)';
    ctx.lineWidth = 1;
    ctx.stroke();
  });

  // Draw rooms
  rooms.forEach((r, i) => {
    r.pulse += r.speed * frameDelta;
    const glow = 0.3 + 0.2 * Math.sin(r.pulse);

    // Room box
    const s = r.size;
    ctx.strokeStyle = `hsla(${r.hue}, 50%, 45%, ${glow})`;
    ctx.lineWidth = 1.5;
    ctx.strokeRect(r.x - s/2, r.y - s/2, s, s);

    // Room label
    ctx.fillStyle = `hsla(${r.hue}, 40%, 55%, ${glow * 0.7})`;
    ctx.font = '9px Courier New';
    ctx.textAlign = 'center';
    ctx.fillText(`room_${i.toString(16)}`, r.x, r.y + 3);

    // Active flash
    if (r.active && frame < r.activateAt + 30) {
      const fade = 1 - (frame - r.activateAt) / 30;
      ctx.fillStyle = `hsla(${r.hue}, 60%, 50%, ${fade * 0.3})`;
      ctx.fillRect(r.x - s/2, r.y - s/2, s, s);
    }
  });

  // Animate agents along connections
  agents.forEach(agent => {
    const conn = connections[agent.connIdx];
    const ra = rooms[conn[0]], rb = rooms[conn[1]];

    agent.t += agent.speed * agent.dir * frameDelta;

    if (agent.t > 1 || agent.t < 0) {
      // Arrived at a room — pick new connection
      const roomIdx = agent.t > 1 ? conn[1] : conn[0];
      rooms[roomIdx].active = true;
      rooms[roomIdx].activateAt = frame;

      const available = connections.filter((c, ci) =>
        ci !== agent.connIdx && (c[0] === roomIdx || c[1] === roomIdx)
      );
      if (available.length) {
        const next = available[Math.floor(Math.random() * available.length)];
        agent.connIdx = connections.indexOf(next);
        agent.dir = next[0] === roomIdx ? 1 : -1;
        agent.t = agent.dir === 1 ? 0 : 1;
      } else {
        agent.dir *= -1;
        agent.t = Math.max(0, Math.min(1, agent.t));
      }
    }

    const x = ra.x + (rb.x - ra.x) * agent.t;
    const y = ra.y + (rb.y - ra.y) * agent.t;

    agent.trail.push({ x, y, age: 0 });
    if (agent.trail.length > 20) agent.trail.shift();

    // Draw trail
    agent.trail.forEach((p, i) => {
      p.age += frameDelta;
      const a = 1 - p.age / 25;
      if (a > 0) {
        ctx.beginPath();
        ctx.arc(p.x, p.y, 2, 0, Math.PI * 2);
        ctx.fillStyle = `hsla(${agent.hue}, 70%, 60%, ${a * 0.5})`;
        ctx.fill();
      }
    });

    // Draw agent
    ctx.beginPath();
    ctx.arc(x, y, 4, 0, Math.PI * 2);
    ctx.fillStyle = `hsla(${agent.hue}, 80%, 65%, 0.9)`;
    ctx.fill();
  });

  // Floating text
  fragments.forEach(f => {
    if (frame < f.delay) return;

    f.life += frameDelta;
    if (f.life > f.maxLife) {
      f.text = murmurs[Math.floor(Math.random() * murmurs.length)];
      f.x = Math.random() * W;
      f.y = Math.random() * H;
      f.life = 0;
      f.maxLife = 200 + Math.random() * 300;
      f.alpha = 0;
    }

    const fadeIn = Math.min(f.life / 40, 1);
    const fadeOut = Math.max(1 - (f.life - f.maxLife + 40) / 40, 0);
    f.alpha = Math.min(fadeIn, fadeOut) * 0.45;

    f.y += f.drift * frameDelta;
    f.x += Math.sin(f.life * 0.01) * 0.2 * frameDelta;

    ctx.font = `${f.fontSize}px Courier New`;
    ctx.fillStyle = `rgba(140, 200, 140, ${f.alpha})`;
    ctx.textAlign = 'left';
    ctx.fillText(f.text, f.x, f.y);
  });

  // Scanline effect
  scanlineAccumulator += frameDelta;
  if (scanlineAccumulator >= 3) {
    scanlineAccumulator -= 3;
    const sy = (frame * 2) % H;
    ctx.fillStyle = 'rgba(0,255,0,0.015)';
    ctx.fillRect(0, sy, W, 2);
  }

  requestAnimationFrame(draw);
}

requestAnimationFrame(draw);
</script>
</body>
</html>
